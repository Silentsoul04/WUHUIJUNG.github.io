---
layout: post
title: 汇编基础之BX和loop
date: 2018-7-22
categories: blog
tags: [汇编基础之BX和loop]
description: 文艺的流氓。
---

# 第五章[bx]和loop指令 #

## 5.1 [bx] ##
<li>BX和[0]有些类似，[0]标识内存单元，它的偏移地址是0</li>
<li>要完整的描述一个内存单元，需要两种信息：</li>

<li>内存单元的地址</li>
<li>内存单元的长度</li>
<li>使用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在DS中，单元的长度(类型)可以由具体指令中的其他操作对象(比如说寄存器)指出，如前边的X,AL</li>

<li>[bx]同样也表示一个内存单元，它的偏移地址在BX中，如果下面的指令: mov ax,[bx],那么这里就有疑问了，这里的bx是什么，mov bx,0 这样的话就是把0给了BX，然后mov ax,[bx] 就是指令偏移地址0的数据</li>
<li>描述性符号“（）”</li>

<li>为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号"()"来表示一个寄存器或一个内存单元中的内容</li>
<li>ax中的内容为0010H，我们可以这样来描述:(ax)=0010H</li>
<li>2000:1000处的内容为0010，我们可以这样描述:(21000H)=0010H</li>
<li>对于mov ax,[2]的内容，这样描述(ax)=((ds)*16+2).假设DS时1000那么乘以16就是往左移一位，然后加上2就是10002.</li>
<li>mov [2],ax,和上面一样，其实没啥算的，就是AX中的内容</li>
<li>以此类推，其他的ADD都是一样的</li>
<li>而push ax就是:(sp)=(sp)-2.先减二嘛，然后在((sp)*16+(sp))=(ax)</li>
<li>那么pop时相反的。先把数据拿出来，然后在加上二.(ax)=((sp)*16+(sp)) (sp)+2=(sp)</li>
<li>约定符号idata表示常量</li>
![](https://i.imgur.com/HFXndy6.png)
<li>问题5.1</li>
![](https://i.imgur.com/y05VGpB.png)
<li>我百度了一下inc的意思，就是说inc ax 意思就是ax+1.就是自增。</li>
<li>这些代码，分析一下，</li>
<li>mov ax,2000H 就是把2000H赋值给AX。</li>
<li>mov ds,ax 把AX中的内容复制给了ds,ds作为段地址</li>
<li>mov bx,1000H 把1000H赋值给了bx</li>
<li>mov ax,[bx] 这里时把[bx]中的内容赋值给了ax，那么ax是16位的，所以说操作起来是一个字的，前面ds段基址是2000BX作为偏移地址1000H，那么就是指向了21000H这里。那么这时候ax的值会是00BE</li>
<li>inc bx 自增1.BX偏移地址加1.我在debug中调式的时候也是这样。</li>
<li>inc bx 自增1.这时候BX就是了21002H了</li>
<li>mov [bx],ax 那么此时ax中的值是00BE，AX是一个字的操作，把AX给了[bx],此时BX指向的地方是21002H，那么BE会在21002H，00会在21003H处</li>
<li>inc bx 自增1.此时在21003H</li>
<li>inc bx 自增1，那么此时在21004H</li>
<li>mov [bx],ax 此时AX中的内容还是没有改变，AX赋值给了21004H和21005H。BE在21004H，00在21005H</li>
<li>inc bx 自增1。21004H+1=21005H</li>
<li>mov [bx],al ，就是说al是ax的低八位也就是BE的内容。复制到了21005处。21005处的内容就是BE,而且AL是字节为单位</li>
<li>inc bx 自增1 21005H+1=21006H</li>
<li>mov [bx],al 把al中的内容赋值给21006H.此时的内容就是BE</li>
<li>总结:这里自己分析了一个程序，这让我受益匪浅，我也知道BX是什么了.这个程序中是把BX看作了偏移地址.</li>
## 5.2 Loop指令 ##

<li>loop指令是一个循环指令,循环的次数有CX指定,循环一次CX-1,直到CX到0循环结束</li>
<li>指令的格式就是:loop标号,CPU指向Loop指令的时候,要进行两步操作</li>
<li>CX=CX-1</li>
<li>判断CX中的值,不为零则转至标号处指向程序,如果为零则向下执行.</li>
<li>那么来写一串代码来看下loop是如何实现循环的</li>
![](https://i.imgur.com/TVlaVjj.png)
<li>把要循环的程序放到给CX赋值和loop 中间,这里的这个S是一个标号.这里的程序可以不止一句,这个标号是自定义的,CX是100,循环一百次😂.</li>
<li>系统执行loop s的时候有两步的操作,先CX=CX-1 然后再判断CX=0.如果等于0那么结束循环执行下面的指令,不等于0然后再跳到标号处,继续执行指令.</li>
<li>那么如果我们没有设置CX的值,初始话的时候,CX的值是存放的我们程序的大小,如果再程序里面没有声明CX的值,那么程序的大小是多少,就会被循环多少次.</li>
## 5.3再debug中跟踪用Loop指令实现的循环程序 ##

<li>计算FFFF:0006单元中的数乘以3,结果存储再DX中.</li>
<li>运算后的结果是否会超出DX所能存储的范围?ffff:0006单元中的数是一个字节型的数据,范围再0~255,因为字节是8位,最大也才是255.所以不会超出,因为DX是16位,所以说存放的下</li>
<li>用循环累加来实现乘法,用哪个寄存器进行累加?使用ffff:0006单元中的数赋值给AX,用DX进制累加.先设置dx=0.然后dx=dx+ax</li>
<li>ffff:0006单元是一个字节单元,ax是一个16位寄存器,数据长度不一样,如果赋值?如果是AX中的值给ffff:0006的话,那么一个字等于两个字节</li>
<li>赋值的话就是说,让AX中的数据的值(数据的大小)和ffff:0006单元中的数据的值(数据的大小)相等.</li>
<li>8位中的11H会和16位中的0011H相等,它们的数据长度不一样,但它们的值是相等的.</li>
<li>FFFF:0001H这里的数据就是12,然后赋值给ax中的,那么ax的值会是0012H.此时ah是等于0的al是等12.</li>
![](https://i.imgur.com/NkMLAzC.png)
<li>那么这里我就是很奇怪了,0ffffH是什么意思?</li>
<li>因为在汇编程序中,数据不能够以字母开头,所以要在前面加上0,虽然加上0等于没有加,但是加上了0编译器就认识,如果是字母开头编译器是不认识的.</li>
<li>如果需要跟踪一个需要循环很多次的程序的话,debug中的G命令和P命令.G命令是跳转. 格式就是G 偏移地址.P指令就是:跟踪到了循环的哪里,直接使用P命令.就会直接跳出循环.</li>
## 5.4 Debug和汇编编译器Masm对指令的不同处理 ##

<li>mov ax,[0] 表示将DS:0处的数据送入al中.因为内存单元中是字节位单位,AX是16位的.所以是送入al中</li>
<li>在MASM中mov ax,[1]是解释为mov ax,1的.一般我们是通过BX来代替的.BX先设置好值,然后再使用bx</li>
<li>如果不适用bx的话,也有一种方法可以使用数字.就是要加上段地址格式:mov al,ds:[0].</li>
<li>p命令再循环中使用就是直接越过循环,g命令也是跳过循环的,还可以定位到偏移地址的哪里.</li>
## 5.5 loop和[bx]的联合应用 ##

<li>计算ffff:0~ffff:b单元中的数据的和,结果存储再dx中</li>

<li>第一,要想到的是,dx中能不能存储的下,结果是肯定的,因为内存单元中是字节为单位,而DX是字为单位的.字节型的数据是八位,范围再0~255之间,而dx是65535.</li>
<li>第二,能不能直接把ffff:0~ffff:b中的数据直接累加到dx中.结果是不行的,因为ffff:0~ffff:b是8位的数据,而DX是十六位的寄存器</li>
<li>第三,把ffff:0~ffff:b中的数据累加到dl中,并且设置dh=0.再来累加,其实这样是不行的,因为dl也是8位寄存器,如果数据超出了范围,那么会造成进位的丢失.</li>
<li>这里就有说两个问题.一个是类型的匹配和一个范围的超出</li>
<li>现在的方法就是使用一个16位的寄存器来做中介.就是用ax来做中介,把数据往ax中存入,然后再往dx中写入</li>
<li>通过loop来实现.</li>
![](https://i.imgur.com/2wsKqXn.png)
<li>这里呢就是通过一个循环来相加的.循环的内容就是,al获取到了ds:[0]的数据,然后把ah高八位变成0,然后再ax中的值放入到了dx中,然后inc是自增1的意思,bx自增1就是=ds:[0+1].</li>
<li>在实际的编程中,经常会遇到,用同一种方法处理地址连续的内存单元中的数据的问题.意思就是说:再编程中会遇到一直使用一个加法啊,或者减法,然后就太麻烦了,就需要使用循环了.而循环呢,需要找到一种规律,才能使用</li>
<li>常量是不能递增的.而变量是可以的</li>
<li>mov al [bx]其中的bx可以看作是一个代表内存单元地址的变量.</li>
## 5.6段前缀 ##

<li>指令mov ax,[bx]中,内存单元的偏移地址由BX给出,而段地址默认再ds中.DS中可以称为一个段前缀.</li>
<li>我们可以再访问的内存单元的指令中显示地给出内存单元的段地址所在的段寄存器</li>
<li>出现再访问内存单元的指令中,用于显示地指明内存单元的段地址 DS: CS: SS: ES:在汇编语言中称为段前缀.mov ax,ds:[0].这就是段前缀.</li>
## 5.7 一段安全的空间 ##

<li>在8086模式中,随意向一段内存空间写入内容是很危险的,因为这段空间中可能存放着重要的系统数据或代码.</li>
<li>像之前我使用debug写入数据,发生了一次错误,估计是写入到了重要的地址中,</li>
<li>在一般的PC机中,DOS方式下,DOS和其他合法的程序一般都不会使用0:200H~0:2FFH的256个字节的空间.所以,我们使用这段空间是安全的.我使用debug中查看了这段空间,没有任何数据.</li>
<li>总结下:向内存中写入内容的时候,不能随意的写入,因为如果覆盖掉了系统的数据而导致的种种后果.那么由一段空间是安全的0:200H~0:2FFH.这段空间中是没有任何的数据的</li> 
## 5.8 段前缀的使用 ##

<li>考虑一个问题.</li>

<li>将内存ffff:0~ffff:b段元中的数据拷贝到0:200~0:20b单元中.</li>
<li>0:200H~0:20bH单元等同于0020:0~0020:b单元,描述的是一段内存空间,为什么要转换呢.因为这样偏移地址就和ffff:0~ffff:b一样.</li>
<li>拷贝的过程应用循环实现.初始化:X=0 循环12次:将ffff:X单元中的数据送入0020:X(需要使用一个寄存器中转) X=X+1</li>
<li>在循环中,源单元ffff:x和目标单元的0020:X的偏移地址X是变量.我们使用bx来存放</li>
<li>将0:200~0:20b用0020:0~0020:b描述,就是为了使目标单元的偏移地址和原单元的偏移地址从同一数值0开始.</li>
![](https://i.imgur.com/t8JWHO7.png)
<li>这段代码就是显示了ffff:0~ffff:b中的内容拷贝到了0020:0~0020:b中去了.因为这里的DS分别赋值了两次。就是把ffff:0的内容存放进去dl中，然后ds执行目标单元。dl再放入目标单元的偏移地址。</li>
<li>这里因为源单元和目标单元相距大于64KB，所以再不同的64KB段内，就需要设置两次ds,可以使用两个寄存器分别存放源单元和目标单元的段地址。</li>
<li>那么之前是说有一个ES是一个多余的寄存器，寄存器不够用的时候，在使用es</li>
![](https://i.imgur.com/INyNmRu.png)

<li>那么这个程序是比较清楚明了的。使用了es来存放目标单元的段地址。这样就不需要来设置两次的DS</li>
## 总结： ##

<li>5.1[bx] 就是讲了微软的masm和debug是不同的。debug是可以使用[1]这样来表示一个偏移地址，masm使用[bx]来表示一个偏移地址的</li>
<li>5.2 loop 循环指令而循环的次数是由CX来指定的</li>
<li>5.3在debug中跟踪loop指令循环的过程，那么在编译器中数据的开头是不能使用字母来表示的，到开头加上一个0</li>
<li>5.4 debug和汇编编译器masm对指令的不同处理 学到了一种格式 mov ds:[1],ax 这种的格式也可以到编译器中使用。</li>
<li>5.5 loop和[bx]的联合应用 就是说我们要把ds:[bx]的数据，写入到别的地方去。那么我们使用循环写入</li>
<li>5.6 段前缀 段前缀就是 DS: 这样的格式的就是叫做段前缀</li>
<li>5.7一段安全的空间，就是说有一段空间是没有任何代码的，没有任何程序的，就是空的。在200H~2FFH</li>
<li>5.8段前缀的使用，如果我们需要把数据放入安全的空间，可以使用es存放安全空间的段地址。</li>


