---
layout: post
title: 实验吧web
date: 2018-8-13
categories: blog
tags: [实验吧web解法]
description: 文艺的流氓。
---
## 先来了解一下什么是PHP的弱类型 ##
 - PHP中有两种比较的符号 ==与===。一个是相等，一个是全等。
 - === 在进行比较的时候，会先判断两种字符串的类型是否相等，在比较。那么意思就是说如果数据类型不相等的话，也就是不会比较值。
 - == 在进行比较的时候，会先将字符串类型转化相同，在比较。   
<code>
$a = 14;
$b = '14';
$a == $b;
是相等的
<code />
 - 也就是说==在比较的时候，a会转化成整形来和b比较。那么此时比较的值，如果字符串中是纯数字。那么就可以比较。<br />如果是字符那么会等于0
 - 那么同时还有一个字符串和整形来相比较   
<code>
$a = 'admin';
$b = 0;
这里的$a和$b是相等的  
<br />
 - 那么是字符串1admin会等于1，而admin1不等于1.还有就是0e123123==0e456456是相等的,0e是科学计数法的数字，<br />无论0的多少次方都是等于0
 - 当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含'.','e','E'并且其数值值在整形的<br />范围之内
 - 该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字<br />符串以合法的数值开始，则使用该数值，否则其值为0。
 - 意思就是说：字符串1aaa当作是整形的话，那么会取开始的值，也就是说1aaa会取1.
 - 这样的话就是就是解释了'admin1'==1 会是false	   
 - 再来看个利用0e绕过判断的。
<code><br />
if (isset($_GET['Username']) && isset($_GET['password'])) {
$logined = true;
$Username = $_GET['Username'];
$password = $_GET['password'];
if (!ctype_alpha($Username)) {$logined = false;}
if (!is_numeric($password) ) {$logined = false;}
if (md5($Username) != md5($password)) {$logined = false;}<br />
if ($logined){<br />
echo "successful";<br />   
}else{<br />
echo "login failed!";<br />
}<br />
}<br />
//只要其中$username的md5值要和$password相等。<br />
//并且username是需要字符串的<br />
//而password时候需要整形的<br />
//所以说只要是字符串加密之后是0e开头和数字加密后是0e开头的，就可以成功的绕过。<br />
<code />
 - 自己还是收集了一些加密过后0e开头的字符串个和数字
<code>   
QNKCDZO<br />
0e830400451993494058024219903391<br />
s878926199a   <br />
0e545993274517709034328855841020 <br />  
s155964671a   <br />
0e342768416822451524974117254469<br />   
s214587387a   <br />
0e848240448830537924465865611904   <br />
s214587387a   <br />
0e848240448830537924465865611904   <br />
s878926199a   <br />
0e545993274517709034328855841020   <br />
s1091221200a   <br />
0e940624217856561557816327384675   <br />
s1885207154a   <br />
0e509367213418206700842008763514   <br />
//这些都是加密之后0e开头的字符串和数字。
<code />
 - **Josn绕过，这个的绕过其实也是利用'admin'=0,的弱类型**
<code>   
<?php   
if (isset($_POST['message'])) {   
    $message = json_decode($_POST['message']);   
    $key ="*********";   
    if ($message->key == $key) {   
        echo "flag";   
    }   
    else {   
        echo "fail";   
    }   
}   
else{   
     echo "~~~~";   
}   
?>   
//传入{"key":0} 那么就是可以绕过的。key的值是0  这里传入的是Json的格式,然后通过解码就是成了0
<code />
# Web1 #
 * 第一题，第一个要求就是不能出现./   第二个要求就是不能出现\\   第三个要求对字符进行了限制大小写。第四个要求<br />就是不能再Url中出现//  第五个要求就是要以web1.php结尾 第六个要求就是不能出p.   第七个要求url不能和/sh<br />iyan/web1.php一样。  所有此时的payload应该是 web1.php.因为要求必须是要web1.php结尾。然后就可以拿到<br />flag
# Web2 #
 * 第二题，当中存在extract这个函数，作用就是把数组中的键变成了一个变量。还有就是一个file_get_contents是<br />把文件读入一个字符串中，那么这样的话就是变量覆盖。
# Wbe3 #
 * 这里unserialize是反序列化，而且下面是对比了username和password的值，
 * 那么就是payload就是 a:2:{s:8:"username";i:0;s:8:"password";i:0;}
 * 也是一个弱类型，就是说int和str比较。和上面的原理差不多。
# Web4 #
 * web4题就是一个正则匹配，只能是数字和字母，传入的值必须是大于9999999长度小于8位。并且匹配当中有没有* - *
 * 那么这样的话，可以使用科学计数法来。9e7就是99999999.就是说e7后面是跟了7个0.
 * ereg函数存在Null截断漏洞。就可以使用%00截断正则匹配
 * 那么最够构造的payload就是9e7%00*-*
 * 这道题目也就是考察了，一个00截断的方法。
# Web5 #
 * 我的思路就是，strcmp是当变量类型不同的时候，虽然会是报错，但是flag还是会出来。主要是考察的strcmp
# Web6 #
 * 这道题目就是$_session没有定义引发的绕过
 * 还有一种就是用火狐浏览器中的cookie删除掉，然后再传入空值就可以了
 * 把其中的phpsession删除掉。然后再传入一个空值就可以了。
 * 因为session是随机生成的，上一次和下一次的是肯定不一样的。所以把session定义为空
 * 原理就是判断session的password的值，那么是可以把这个赋值过程中的值删除的。
# Web7 #
 * 这一道题目是sha1比较
 * 这道的题目其实和Md5的那道题目差不多，只要找两个sha1加密过后是0e开头的值就可以绕过的
 * aaroZmOk   aaK1STfY 加密过后就是0e开头
 * 第二种方法就是使用数组绕过，sha1是不能加密数组的然后会返回错误，也是返回的是0.
 * 第二种的payload name[]=12312&password[]=3232
# Web8 #
 * 加密的那么我就是逆算出来，可以看到的时候上面显示反转一下，然后再通过for循环出来的值，再进行了加密
# Web9 #
 * 这题的环境是要手动改的，比如数据库账号密码什么的。改完之后我们才不多就可以开始做题了。这题非常的基础，<br />就是一个普通注入，通过审计发现，我们提交的user要和md5过的pass相同，本来是很难实现的，但是这里存在sql<br />注入漏洞，我们可以构思sql语句来绕过。payload: user=-1’ union select “c4ca4238a0b923820dcc509<br />a6f75849b” %23&pass=1，这里还有一个小问题，就是如果我们是在输入框里面提交的话，那么%23就要变成#号了。
# Web10 #
 * 这道题就是传入来的值是能够被解码一次然后还能够等于hackerDJ
 * 那么意思就是说要把hackerDJ URL转码两次就可以了。
# Web11 #
 * 分析了一下代码，代码的意思就是说要查询出数据库中的user字段要等于admin，那么我的思路就是把后面密码字<br />段注释掉。而SQL查询语句就是把User的那么的括号给闭合掉。payload=user=admin') and 1 = 1 %23pass=1
 * and 1 = 1返回的是真，所以说会返回一条记录。用or 1= 1就会返回多条记录
# Web12 #
 * 代码的意思就是说，前面是判断了用了那种方法获取到的客户端的IP地址。如果没有的话会把IP给成0.0.0.0 那么就是没有地址
 * 可以使用burp来抓包，把其中的X-forwarded-For修改为1.1.1.1 然后就会输出flag.
# Web13 #
 * 并没有Web13.......
# Web14 #
 - 待更新。。
