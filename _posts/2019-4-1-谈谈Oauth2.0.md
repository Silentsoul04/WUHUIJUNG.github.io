---
layout: post
title: 谈谈Oauth2.0
date: 2019-4-1
categories: blog
tags: [WEB]
description: 文艺的流氓。
---

####  一.这是我今年的第一篇博客。我希望这是一个好的开始,今年需要更加的努力

​	这几天呢,一直在学习OAuth2.0的一些攻击方法.我自己是只挖到了一个OAuth2.0的一个漏洞,其实也是很简单,没有对跳转的域名进行校验,导致直接带着code跳转了。

​	我就开始想怎么去研究一下这个OAuth2.0了。关于OAuth的原理,我是看的阮一峰老师的博客地址：http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

#### 二.OAuth2.0中的基本概念与授权流程

作为第三方登录服务提供方，其核心矛盾点是 既要让用户在对接服务的 APP 上完成登录，同时还不能让该 APP 拿到用户的密码凭证 。解决这一矛盾的利器就是 token（中文译为令牌），而 OAuth 协议的最终目的就是给第三方应用下发 token，它记录了用户的登录或授权状态。通过将 token 下发给第三方应用，既能让 APP 登录并拿到用户许可的数据，也可以将用户的密码凭证牢牢拽在服务自己手里。



上面的论述可能侧重了第三方登录，实际上登录只是一个授权的过程，OAuth 2.0 协设计的目的在于开放授权。对于一个应用，其最终目的还是在于拿到用户存储在资源服务器上的用户数据，所以登录授权还只是第一步，后续 APP 还需要携带 token 去资源服务器请求用户数据，这个时候是一个鉴权的过程，OAuth 协议的主要目的在于授权，至于鉴权，实现上主要是还是对请求传递过来的 token 进行解析和验证，这一块相对要简单一些，所以本文主要讲解 OAuth 授权的过程。

#### 2.1OAuth2.0中定义的几个角色

- 资源所有者 (resource owner)

受保护资源所属的实体，比如资源的所有人，下文的用户即为资源所有者。

- 资源服务器 (resource server)

托管受保护资源的服务器，能够响应持有访问令牌的资源访问请求，可以与授权服务器是同一台服务器，也可以分开。

- 客户端 (client)

客户端是 OAuth 服务的接入方，其目的是希望请求用户存储在资源服务器上的受保护资源。

- 授权服务器 (authorization server)

授权服务器的主要职责是验证资源所有者的身份，并依据资源所有者的许可向客户端下发访问令牌。

先说一个小故事.小明请假要回家一趟,走到公司大门的时候,准备出去的时候.这时候门口的大爷拦住了小明,问小明的请假条呢。小明当然没有请假条.门口的大爷就带着小明到了老板办公室找到了老板请假。请假条上写的是只能够回家一天，然后请到假的小明回家了,第二天小明还想拿昨天的请假条请假回家,但是门口的大爷不认了。必须得到老板办公室办理今天的请假。

上面这个小故事,其中资源所有者就是老板,资源服务器就是公司,小明就是客户端,而办公室就是整个授权的流程的授权中心。也就是授权服务器。

#### 2.2基本概念

##### 2.2.1 访问令牌（access token）

还记得故事中大爷问小明要的请假条吗？(请假条)凭证限制了小明只能回家一天，并且凭证还是具备生命周期的，一天之后小明再拿着过期的凭证大爷也不认了。

实际上故事中的凭证对应的是 OAuth 2.0 中的访问令牌，访问令牌是在用户授权许可下，授权服务器下发给客户端的一个授权凭证，该令牌所要表达的意思是“ 用户授予该 APP 在多少时间范围内允许访问哪些与自己相关的服务或数据 ”，所以访问令牌主要在 时间范围 和 权限范围 两个维度进行控制，此外访问令牌对于客户端来说是非透明的，外在表现就是一个字符串，客户端无法知晓字符串背后所隐藏的用户信息，因此不用担心用户的密码凭证会因此泄露。

##### 2.2.2 刷新令牌 (refresh token)

刷新令牌的作用就是在于更新访问令牌,访问令牌的生命周期比较短,如果访问令牌泄露了,可以减少影响。但是同时也是存在一个问题,访问令牌的周期短,导致用户需要频繁的去请求授权,虽然说可以通过一定的机制进行静默授权,但是频繁的调用授权接口对于服务器也是一种压力,此时可以在下发访问令牌的时候同时下发一个刷新令牌,刷新令牌的生命周期长于访问令牌,在访问令牌过期了的时候可以利用刷新令牌去授权服务器换取新的访问令牌。不过协议对于刷新令牌没有强制规定,是否需要该令牌客户端可以自行选择。

##### 2.2.3 回调地址 (redirect uri)

OAuth 2.0 是一类基于回调的授权协议，以授权码模式为例，整个授权需要分为两步进行，第一步下发授权码，第二步根据授权码请求授权服务器下发访问令牌。OAuth 在第一步下发授权码时，是将授权码以参数的形式添加到回调地址后面，并以 302 跳转的形式进行下发，这样简化了客户端的操作，不需要再主动去触发一次请求，即可进入下一步流程。

回调的设计存在一定的安全隐患，坏人可以利用该机制引导用户到一个恶意站点，继而对用户发起攻击。对于授权服务器而言，也存在一定的危害，坏人可以利用该机制让授权服务器变成“肉鸡”，以授权服务器为代理请求目标地址，这样在消耗授权服务器资源的同时，也对目标地址服务器产生 DDOS 攻击。

为了避免上述安全隐患，OAuth 协议强制要求客户端在注册时填写自己的回调地址，其目的是为了让回调请求能够到达客户端自己的服务器，从而可以走获取访问令牌的流程。客户端可以同时配置多个回调地址，并在请求授权时携带一个地址，服务器会验证客户端传递上来的回调地址是否与之前注册的回调地址相同，或者前者是后者集合的一个元素，只有在满足这一条件下才允许下发授权码，同时协议还要求两步请求客户端携带的回调地址必须一致，通过这些措施来保证回调过程能够正常到达客户端自己的服务器，并继续后面拿授权码换取访问令牌的过程。如果对回调地址不严格那么就会造成带着code跳转就可以登录你的账户。

##### 2.2.4 权限范围 (scope)

访问令牌自带过期时间，可以在时间维度上对授权进行控制，而在权限范围上，OAuth 引入了一个 scope 的概念。Scope 可以看做是一个对象，包含一个权限的 ID，名称，以及描述信息等，比如 “获取您的基本资料（头像、昵称）”。应该在接入 OAuth 服务时必须向服务提供方申请相应的 scope，并在请求授权时指明该参数，这些权限在用户确认授权时，必须毫无保留的展示给用户，以让用户知道本次请求需要访问用户的哪些数据或服务。

#### 2.3 基本授权流程

OAuth 2.0 协议定义了 4 种授权模式，其中最具代表性的是授权码模式，我们将在 3.1 节中详细介绍，这里先简单体会一下 OAuth 2.0 的授权流程，交互时序图如下：

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20190402085105.png)

假设整个流程开始之前，用户已经登录，那么整个授权流程如下：

```
1.客户端请求资源所有者（用户）授权，一般都是由授权服务器进行引导
2.资源所有者实施授权（采用 4 种授权模式中的一种），客户端拿到用户的授权凭证
3.客户端携带用户授权凭证请求授权服务器下发访问令牌
4.授权服务器验证客户端出示的授权凭证，并下发访问令牌
5.客户端携带访问令牌请求存储在资源服务器上的用户受保护资源
6.资源服务器验证客户端出示的访问令牌，通过则响应客户端的请求
```

整个过程中，客户端都无法接触到用户的密码凭证信息，客户端通过访问令牌请求受保护资源，用户可以通过对授权操作的控制来间接控制客户端对于受保护资源的访问权限范围和周期。

#### 三.四种授权模式

OAuth 2.0 相对于 1.0 版本在授权模式上做了更多的细化，已定义的授权模式分为四种：

1. 授权码模式（Authorization Code Grant）
2. 隐式授权模式（Implicit Grant）
3. 资源所有者密码凭证模式（Resource Owner Password Credentials Grant）
4. 客户端凭证模式（Client Credentials Grant）

#### 3.1 授权码授权模式

授权码模式在整个授权流程上与 1.0 版本最为贴近，但是流程上还是要简化许多，也是 OAuth 2.0 中最标准，应用最为广泛的授权模式。这类授权模式非常适用于具备服务端的应用，当然现在大多数 APP 都有自己的服务端，所以授权码模式拥有最广泛的应用场景，下图为授权码各个角色之间的交互时序：

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20190402091336.png)

**整个授权流程说明如下（具体参数释义见下文）：**

```
1.客户端携带 client_id, scope, redirect_uri, state 等信息请求授权服务器下发 code
2.授权服务器验证客户端身份，通过则询问用户是否同意授权（此时会跳转到用户能够直观看到的授权页面，等待用户点击确认授权）
3.假设用户同意授权，此时授权服务器会将 code 和 state 拼接在 redirect_uri 后面，并以 302 形式下发 code
4.客户端携带 code, redirect_uri, 以及 client_secret 请求授权服务器下发 access_token
5.授权服务器验证客户端身份，同时验证 code，以及 redirect_uri 是否与第一步相同，通过则下发 access_token，并选择性下发 refresh_token
```

##### 3.1.1 获取授权码

授权码是授权流程的一个中间临时凭证，是对用户确认授权这一操作的一个短暂性表征，其生命周期一般较短，协议建议最大不要超过 10 分钟，在这一有效时间内，客户端可以通过授权码去授权服务器请求换取访问令牌，授权码应该采取防重放措施。

**请求参数说明:**

| 名称          | 是否一定要 | 描述信息                                                     |
| ------------- | ---------- | ------------------------------------------------------------ |
| Response_type | 必须       | 对于授权码模式来说`response_type=code`                       |
| Client_id     | 必须       | 客户端ID,用于标识一个客户端,在注册应用时生成                 |
| Redirect_uri  | 可选       | 授权回调地址,具体可以看上面的2.2.3小结                       |
| scope         | 可选       | 权限范围，用于对客户端的权限进行控制，如果客户端没有传递该参数，那么服务器则以该应用被许可的所有权限代替 |
| state         | 推荐       | 用于维持请求和回调过程中的状态，防止 CSRF攻击，服务器不对该参数做任何处理，如果客户端携带了该参数，则服务器在响应时原封不动的进行返回 |

**请求参数示例:**

```rst
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1  
Host: server.example.com	
```

客户端携带上述参数请求授权服务器，授权服务器会验证客户端的身份以及相关参数，并在确认用户已登录的前提下弹出授权页询问用户是否同意授权，如果用户同意则会将授权码（code）和 state 信息添加到回调地址后面，并以 302 的形式下发。

成功响应参数说明：

| 名称  | 是否需要 | 描述信息                                                     |
| ----- | -------- | ------------------------------------------------------------ |
| code  | 必须     | 授权码,授权码代表了用户确认授权的暂时性凭证。最大生命周期不能够太久 |
| state | 可选     | 如果客户端传递了该参数,则必须原封不动的返回                  |

**成功的响应示例:**

```rst
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=xyz
```

如果请求参数错误，或者服务器端响应错误，那么需要将错误信息添加在回调地址后面，同样以 302 形式下（回调地址错误，或客户端标识无效除外）。

**错误响应参数说明：**

| 名称              | 是否必须 | 描述信息                                  |
| ----------------- | -------- | ----------------------------------------- |
| error             | 必须     | 错误代码                                  |
| Error_description | 可选     | 具备可读性的错误描述信息                  |
| Error_uri         | 可选     | 错误描述信息页面地址                      |
| state             | 可选     | 如果客户端传递了该参数,则必须原封不动返回 |

**错误响应示例:**

```
HTTP/1.1 302 Found
Location: https://client.example.com/cb?error=access_denied&state=xyz
```

##### 3.12 下发访问令牌

授权服务器的授权端点在以 302 形式下发 code 之后，用户 User-Agent，比如浏览器，将携带对应的 code 回调请求用户指定的 redirect_url，这个地址应该能够保证请求打到应用服务器的对应接口，该接口可以由此拿到 code，并附加相应参数请求授权服务器的令牌端点，授权端点验证 code 和相关参数，验证通过则下发 access_token。

**请求参数说明：**

| 名称         | 是否必须 | 描述信息                                          |
| ------------ | -------- | ------------------------------------------------- |
| Grant_type   | 必须     | 对于授权模式`grant_type=authorization_code`       |
| code         | 必须     | 上一步骤的授权码                                  |
| Redirect_uri | 必须     | 授权回调地址,                                     |
| Client_id    | 必须     | 客户端ID，用于表示一个客户端,在注册应用的时候生成 |

如果在注册应用时有下发客户端凭证信息（client_secret），那么客户端必须携带该参数以让授权服务器验证客户端的真实性。针对客户端凭证需要多说的一点就是不能将其存储或传递到客户端，客户端无法保证 client_secret 的安全，应该始终将其存储在应用的服务器端，当下发授权码回调请求到应用服务器时，在服务器端携带上 client_secret 继续请求下发令牌。

**请求参数示例：**

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
```

授权服务器需要验证客户端的真实性，以及是否与之前请求授权码的客户端属同一个（请求授权时的信息可以记录在授权码中，或以授权码为 key 建立缓存），授权服务器还要保证授权码处于生命周期内，且只能被使用一次。验证通过之后，授权服务器生成 access_token，并选择性下发 refresh_token，OAuth 2.0 协议明确了 token 的下发策略，对于 token 的生成策略没有做太多说明，不过相关 RFC 补充文档为生成 token 提供了指导，目前主要的 token 有 BEARER、MAC 等类型。

**成功响应参数说明**

| 名称          | 是否必须 | 描述信息                                                     |
| ------------- | -------- | ------------------------------------------------------------ |
| Access_token  | 必须     | 访问令牌                                                     |
| Token_type    | 必须     | 访问令牌类型,比如BEARER,MAC等                                |
| Expires_in    | 推荐     | 访问令牌的生命周期，以秒为单位，表示令牌下发后多久时间过期，如果没有指定该项，则使用默认值 |
| Refresh_token | 可选     | 刷新令牌,选择性下发,参加2.2.2                                |
| scope         | 可选     | 权限范围,如果最终下发的访问令牌对应的权限范围与实际应用指定不一致,则必须在下发访问令牌时用该参数指定说明。 |

最后访问令牌以 JSON 格式响应，并要求指定响应首部 `Cache-Control: no-store` 和 `Pragma: no-cache`。

**成功响应示例**

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache
{
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "example_parameter":"example_value"
}
```

**错误响应示例**

| 名称              | 是否必须 | 描述信息                 |
| ----------------- | -------- | ------------------------ |
| error             | 必须     | 错误代码                 |
| Error_description | 可选     | 具备可读性的错误描述信息 |
| Error_uri         | 可选     | 错误描述信息页面         |

**错误响应示例：**

```
HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "error":"invalid_request"
}
```

##### 3.1.3 对于授权码模式的一点小感悟

授权码授权模式是 OAuth 2.0 协议已定义 4 种模式中最严谨的模式，其余 3 中模式都是建立在一些特殊场景下，并对这些场景做了一些妥协和优化。授权码授权流程分为两步走，将用户授权与下发访问令牌分开，这给授权带来了更多的灵活性，正常授权过程中必须经过用户登录这一步骤，在用户已登录的前提下，可以直接询问用户是否同意授权，但是在一些场景下，比如内部走 SSO（单点登录）的应用集成了基于 OAuth 授权的第三方应用，这个时候在 OAuth 授权登录第三方应用时，用户体验较好的流程是不需要用户再次输入用户名和密码的，这就需要将外围 APP 的登录态传递给嵌套的应用，但是这样是存在安全问题的，用户的登录态必须把握在走 SSO 登录流程的应用手上，这样的场景下授权码授权模式的两步走流程就可以满足在不交出用户登录态的情况下，无需再次登录即可授权。

内部应用可以拿着第三方应用的 client_id 等信息代替第三方应用去请求获取 code，因为自己持有用户的登录态，所以过程中无需用户再次输入用户名和密码，拿到 code 之后将其交给第三方应用，第三方应用利用 code 和自己的 client_secret 信息去请求授权服务器下发 token，整个流程内部应用不需要交出自己持有的用户登录态，第三方应用也无需交出自己的 client_secret 信息，最终却能够实现在保护用户密码凭证的前提下无需再次登录即可完成整个授权流程。



