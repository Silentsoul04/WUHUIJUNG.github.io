---
layout: post
title: 栈
date: 2018-7-19
categories: blog
tags: [栈]
description: 文艺的流氓。
---
# 栈学习 #
<pre>
栈是一种特殊的访问方式的存储空间.特殊性就是最后进去的,最先出去
我用一个盒子和几本书来描述,我们现在要入栈,1号书进去接着2号数进去然后3号数进去,那么出栈的规则就是像我们拿出书来,是不是先拿3号在拿2号接着1号,这样的话就是说栈的出口和入口时同一个
栈的两个基本操作,入栈和出栈
入栈:将一个新的元素放到栈顶.
出栈:从栈顶取出一个元素
栈顶的元素总时最后入栈,需要出栈时,又最先被从栈中取出
栈的操作原则:LIFO(后进先出)
3.7CPU提供的栈机制
1.8086CPU提供相关的指令来以栈的方式访问内存空间
2.这意味着,我们再基于8086CPU编程的时候,可以将一段内存当作栈来使用
而且我们把一段内存来当作什么使用都是我们的事.我们也可以当作指令或者数据
8086CPU提供入栈和出栈指令:(最基本的)
PUSH(入栈)
POP(出栈)
它们的用法就是
push ax:将寄存器AX中的数据送入栈中
pop ax:从栈顶取出数据送入AX中
8086CPU的入栈和出栈都是以字为单位进行的.因为CPU是16位的
来看下这些指令再栈中的情况</pre>
![](https://i.imgur.com/PxcqGsB.png)
<pre>
栈的范围就是:10000H~1000FH.可以看到的是我们先是存入的是AX,AX的值是0123那么高位时01低位时23.这时候最存入的数据会再栈的范围的最大处。然后的数据会慢慢的从最大的地方到最小的地方。然后处栈的时候，会先从最小的地方开始出栈。
字型数据用两个单元存放，一个是高八位一个是低八位。
问题？
1.CPU是如何知道一段内存空间被当作栈使用？
2.执行push和pop的时候，如何知道那个单元是栈顶单元
就是寄存器CS和IP中存放着当前指令的段地址和偏移地址
在8086CPU中呢，又两个寄存器
    段寄存器SS    存放栈顶的段地址
    寄存器SP        存放栈顶的偏移地址
任意时刻，SS:SP指向栈顶元素
结论就是任意的时候，SS:SP都是指向的栈顶单元
push ax 把AX的数据送入栈中，
    1.SP=SP-2
    2.将AX中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶
这段话呢，我的理解就是指向push ax的时候。SP就是偏移地址减2.因为AX的单位是字。把AX的值送入了栈顶。然后又指向了新栈顶。</pre>
![](https://i.imgur.com/mMVjvkb.png)
<pre>
我们要把一个东西送入栈中的时候，我们要先减2.
如果是pop那么就是相反的SP=SP+2.要送入一个东西的话，要先减二指向一个新的栈顶才有地方放入
pop的话就是先把东西拿出来然后再加2.
问题3.6：如果我们将10000H~1000FH这段空间当作栈，初始状态栈时空的此时SS=1000H,SP=?
我是这样想的，就是说如果栈中空间是空的话，那么会指向栈顶。
而课本上面说是SP=0010H.就是000F的下一位。
如果栈空的话，SS:SP指向栈空间最高地址的下一个单元
执行了push ax后SS:SP指向栈中的第一个元素。而不是第0个。SP-2
</pre>
![](https://i.imgur.com/nzEL5vj.png)
<pre>
pop把数据送出去,在内存中是存在的。这个数据是存在的。但是在下一次push会被覆盖。这就是像我们硬盘一样，格式化之后，只是把索引变成了0.并没有一个一个的删除数据，等到存入数据的时候，一个一个的覆盖掉。内存中是不存在删除数据的机制的，只有被覆盖掉。
问题3.6分析
我们将10000H~1000FH这段空间当作栈段，SS=1000H，栈空间大小为16字节栈最底部的字单元地址为1000:000E.也就是1000F+1
任意时刻，SS:SP指向栈顶，当栈中只有一个元素的时候
SS=1000H，SP=000EH
栈为空的话，那么就是说栈中什么元素都没有那么，000E+2=0010H 
所以当栈为空的时候，SS=1000H,SP=10H
那么也可以这样说：
任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就是不存在栈顶元素。因为为空的话，SP=10H，那么就超出了栈的范围。只有栈中有一个元素的时候，栈顶才存在。
所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址，为栈最底部的子单元的偏移地址+2
栈最底部字单元的地址为1000:000E,所以栈空时，SP=10H
</pre>
# POP指令的执行过程 #
## pop ax ##
<pre>
1.将SS:SP指向的内存单元处的数据送入AX中
2.SP=SP+2,SS:SP指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶.
可以看的是这样的一个过程,但是又一点需要注意的是,送出去的数据是复制过去的,不是剪切的.这些数据只能覆盖掉.就像格式化硬盘的话,就是改变了索引.如果用一些专门的格式化工具的话,那么就是会被覆盖掉.</pre>
![](https://i.imgur.com/xxpHgAA.png)
<pre>注意:出栈后,SS:SP指向新的栈顶1000EH,pop操作前的栈顶元素,1000CH处的2266H依然存在,但是,它已不在栈中
当再次执行push等入栈指令后,SS:SP移动至1000CH,并再里面写入新的数据,它将被覆盖.
总结:今天学习了栈。学习了怎么把数据送入栈中和把数据从栈中取出，然后还学了栈顶。我们把数据存进去的时候存入的位置，还有取出来时候的位置。</pre>
# 3.8栈顶超界的问题 #
<pre>
SS和SP只记录了栈顶的地址,依靠SS和SP可以保证再入栈和出栈的时找到栈顶,可是,如何能够保证再入栈,出栈时,栈顶不会超出栈空间?
我们来看下Push超出栈空间.其实这个也可以叫时溢出,这就像时一个水杯,倒水进去,结果倒满了,但是还倒进去水了,然后再满出来到其他的地方.这是栈满的时候使用push
</pre>
![](https://i.imgur.com/29Im4pK.png)
再来看下栈空的时候,使用pop指令取值,其实就是像push一样.不过pop时栈低越界.
![](https://i.imgur.com/JGFW81r.png)
## 栈顶超界时危险的: ##
<pre>因为我们既然将一段空间安排为栈,那么在栈空间之外的空间里很可能存放了具有其他用途的数据,代码等,这些数据,代码可能时我们自己的程序中的,也可能是别的程序中的(我们当然会使用别人的程序)
但是由于我们在入栈出栈的时候的不小心,而将这些数据,代码意外地改写,将会引发一连串的错误.
我自己的理解的就是:栈超界了,那么有可能会导致自身的计算机系统出现漏洞,然后黑客进入你的系统,就可以为所欲为了.比如:MS08067永恒之蓝.
我们也希望CPU来帮我们搞定这个问题.
1.CPU中又记录栈顶上限和下限的寄存器,我们可以通过填写这些寄存器来指定栈空间的范围,然后,CPU在执行push指令的时候靠检测栈顶上限寄存器,在执行pop指令的时候靠检测栈顶下限寄存器保证不会超界
实际情况是:8086CPU没有这种寄存器
2.8086CPU不会来保证对栈的操作不会超界,就是说8086CPU只知道栈顶在何处(因为由SS:SP来指示的).不知道栈的空间有多大.意思就是CPU只知道要执行指令(是由CS:SP指示的),而不知道我们的要执行的指令有多少.
这样的话,可以看出CPU的工作原理,只考虑当前的情况
1.当前的栈顶在何处
2.当前要执行的指令是那一条.
也就是说CPU并不会知道因为栈超界而产生的问题
结论:
    1.我们在编程的时候要自己操心栈顶超界的问题,要根据可能用到的最大栈空间,来安排栈的大小,防止入栈的数据太多而导致的超界.
    2.执行出栈操作的时候也要注意,以防栈空的时候继续出栈而导致的超界</pre>
# 3.9 push, pop指令和栈与内存 #
<pre>
push和pop指令时可以在寄存器和内存之间传送数据的.栈空间也是内存空间的一部分,它只是一段可以以一种特殊的方式进行访问的内存空间.规定了一种特殊方式的内存:Advanced after.这种特殊的方式是对CPU很有用的,所以说栈是很有用的.
push和pop指令的格式(1)
    1.push寄存器:将一个寄存器中的数据入栈
    2.pop寄存器:出栈,用一个寄存器接收出栈的数据
例如:
    1.push ax
    2.pop ax
push和pop指令的格式(2)
    1.push段寄存器:将一个段寄存器中的数据入栈
    2.pop段寄存器:出栈, 用一个段寄存器接收出栈的数据
例如:
    1.push ds
    2.pop es
可以对段寄存器操作.段寄存器都是以S结尾的,通用寄存器是用X结尾的
push和pop指令的格式(3)
    1.push内存单元:将一个内存单元处的字入栈(栈操作都是以字为单位的)
    2.pop内存单元:出栈,用一个内存单元接收出栈的数据
例如:
    1.push [0]
    2.pop [2]
指令执行时,CPU要知道内存单元的地址,可以在push,pop指令中给出内存单元的偏移地址,段地址在指令执行时,CPU从DS中取得.数据的段地址时从DS中获得,代码的段地址时从CS中获得,栈的段地址时从SS中获得.</pre>
## 问题3.7<br> ##
我们知道是不能直接给段地址赋值的.
![](https://i.imgur.com/LDL41mf.png)
所以我们通过通用寄存器来确定段地址,这里说将10000H~1000FH这段空间当作栈.<br>
<pre>
mov ax,1000H
mov ss,ax
mov sp:0010H 栈是空的,那么F+1=10
push ax
push bx
push ds
</pre>
![](https://i.imgur.com/Xq7IwkK.png)
那么我就编写指令编写为什么 <br />
<pre>
mov ax,1000H 
mov ss,ax        通过通用寄存器来确认段地址
mov sp,0010H 确认偏移地址,因为栈是空的,所以栈顶指向的是F+1 因为栈的操作是一个字的
mov ax,001AH
mov bx,001BH
push ax
push bx
mov ax,0000H
mov bx,0000H
pop bx
pop ax
</pre>
从这个程序来说,用栈来暂存以后需要恢复的寄存器中的内容时,出栈的顺序要和入栈的顺序相反,因为最后入栈的寄存器的内容在栈顶,所以在恢复时,要最先出栈.<br />
![](https://i.imgur.com/Yw09vqz.png)
我也就是直接写答案了咯
<pre>
mov ax,1000H
mov ss,ax
mov sp,0010H
mov ax,002AH
mov bx,002BH
push ax
push bx
pop bx
pop bx
</pre>
![](https://i.imgur.com/cqtYhGZ.png)
![](https://i.imgur.com/qQ9une3.png)
我觉得这三个空就是:
<pre>
1.mov ax,1000H
2.mov ss,ax
3.mov ss,2H
</pre>
那么这是为什么呢?其实就是因为push有两个步骤,先SP-2然后再存放数据.那么这里SP时2那么会等于10000H<br />
# 结论 #
<pre>push,pop实质上就是一种内存传送指令,可以再寄存器和内存之间传送数据,与mov指令不同的是,push和pop指令访问的内存单元的地址不是再指令中给出的,而是由SS:SP指出的.<br>
同时,push和pop指令还要该百年SP中的内容.<br>
我们要十分清楚的是,push和pop指令同mov指令不同,CPU执行mov指令只需要一步操作,就是传送.而执行push,pop指令却需要两步操作.<br>
执行Push时:<br>
    1.先改变SP:后向SS:SP处传送<br>
执行pop时<br>
    2.先读取SS:SP处的数据,后改变SP<br>
push,pop等栈操作指令,修改的只是SP,也就是说栈顶的变化范围最大为:0~FFFFH.意思就是说:SP是一个偏移地址.然后是16位的.2的16位最大就是FFFF. <br>
提供:SS:SP指示栈顶,改变SP后写内存的入栈指令,读内存后改变SP的出栈指令<br></pre>
# 总结: #
    1.8086CPU提供了栈操作的机制,方案如下:再SS:SP中存放栈顶的段地址和偏移地址,提供入栈和出栈指令,他们根据SS:SP指示的地址,按照栈的方式访问内存单元.
    2.push指令的执行步骤
    	1.SP=SP-2
    	2.向SS:SP指向的字单元中送入数据
    3.pop指令的指向步骤
    	1.从SS:SP指向的字单元中读取数据
    	2.SP=SP+2
	4.任意时刻,SS:SP指向栈顶元素<br>
	5.8086CPU只记录栈顶,栈空间的大小我们要自己管理<br>
	6.用栈来暂存以后需要恢复的寄存器的内容时,寄存器出栈的顺序要和入栈的顺序相反<br>
	7.push和pop实质上是一种内存传送指令.<br>