---
layout: post
title: Shell进阶
date: 2018-11-6
categories: blog
tags: [Linux]
description: 文艺的流氓。
---

#### 知识才是力量！

#### Shell传递参数

#### 第一种：

在执行Shell脚本的时候,给里面的变量传递值，比如有一个这样的实例：

```bash
#!/bin/bash
# 这是一个文件里面
echo "文件名:$0"
echo "本文的作者是:$1"
echo "他的水平$2"
echo "邮箱是:$3"
echo "QQ号是:$4"
echo "有问题是否可以加QQ?$5"
```

其中需要传输五个值。其中`$0`的值就是第一个。也就是文件名。可以这样来传值

```bash
./sh_1.sh wujinlin 垃圾 1809070261@qq.com 1809070261 是
```

回显的结果就是：(运行前西先给一个权限给文件)

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181106200620.png)

按照上面的意思就是说 `$1 $2 $3 $4 $5 ...` 就是代表着每一个位置的地方。

还有其他的几个特殊符号：

| parameter | Effect                                                  |
| --------- | ------------------------------------------------------- |
| $#        | 获取传递到脚本的参数个数                                |
| $*        | 获取传递到脚本的值                                      |
| $$        | 获取脚本当前进程ID号                                    |
| $!        | 获取后台运行的最后一个进程的ID号                        |
| $@        | 作用是和$*一样的                                        |
| $-        | 显示Shell使用的当前选项                                 |
| $?        | 显示最后命令退出状态，0表示没有错位，其他的值表示有错误 |

##### 讲一些`$*`和`$@`的区别

当`$*`和`$@`的区别不被双引号包括的时候,他们之间没有任何的区别,都是将收到的每一个参数看做为一份数据.用空格来进行分割

但是它们被双引号`""`包含时,就会有区别了：

- `"$*"` 会将所有的参数从整体上看做一份数据,而不是把每一个参数都看做一份数据
- `"$@"`仍然将每一个都看做一份数据,彼此之间是独立的。

如果使用`echo` 直接输出`"$@"`和`$*`的话,是看不出效果的。但是使用`for`循环的话,是可以看得出效果的。

```bash
#!/bin/bash
echo "文件名是:$0"
echo "第一个参数:$1"
echo "第二个参数:$2"
echo "第三个参数:$3"

# 使用$*
for i in "$*"
do
    echo ${i}
done
# 使用$@
for i in "$@"
do
    echo ${i}
done
```

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107141042.png)

可以很清楚的看得到。`$*`只循环了一次,而`$@`循环了三次。这就是他们的区别

##### $?获取上一个命令退出状态

需要有两个文件,其中文件一随意输出,只要能够正常。然后在使用文件二获取退出状态

```bash
#!/bin/bash
# 这是文件一
echo $a
```

```bash
#!/bin/bash
# 这是文件二
echo $?
```

先运行第一个文件,然后在运行第二个文件

```bash
./a.sh
./b.sh
```

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107142712.png)

这里为什么使用`0`来代表退出正常呢,而别的语言是使用有数来代表正确。我觉得是发生错误的类型比较多。然后都是使用一个来进行标志。导致比较混乱。(自己没有仔细研究过)

##### $?获取函数的返回值

代码如下：

```bash
function demo(){
    return `expr 2 + 2`
}

demo
a=$?
echo $a
```

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107143153.png)

这里的意思就是说,接收到的函数返回值。赋值给了`a`

#### 第二种：

Getopts是bash中用来获取分析命令行参数的工具

使用getopts来进行传值：命令方式：`getopts ":a:b:c:"` 使用一个while来进行解释

```bash
while getopts ":a:b:c:" aaa
do
    case $aaa in
        a)
        echo "参数a的值$OPTARG"
        ;;
        b)
        echo "参数b的值$OPTARG"
        ;;
        c)
        echo "参数c的值$OPTARG"
        ;;
        ?)
        echo "未知参数"
        exit 1;;
    esac
done
```

运行的时候这样传入值

```bash
./a.sh -a 1 -b 2 -c 3
# 输出的值
参数a的值1
参数b的值2
参数c的值3
```

#### Shell基本运算符

Shell和其他的语言差不多，支持多种运算符。其中有以下几种

1. 算数运算符
2. 关系运算符
3. 布尔运算符
4. 字符串运算符
5. 文件测试运算符

进行运算操作在bash中需要使用expr来进行运算

expr是计算表达式的一个工具。能够完成我们需要的运算

使用的时候需要加上反引号``。比如在bash中输入

```bash
#!/bin/bash
echo `expr 1 + 1`
# 注意在1+1表达式中需要加上空格，才能完成运算，不然可能会被当做是一个字符串输出
```

##### 算术运算符

一些常用的算术运算符

| Operator | Description            | Example                  |
| -------- | ---------------------- | ------------------------ |
| +        | 加法                   | `expr 1 + 1`             |
| -        | 减法                   | `expr 2 - 1`             |
| *        | 乘法                   | `expr 2 \* 2`            |
| /        | 除法                   | `expr 4 / 2`             |
| %        | 取余                   | `expr 5 %2`              |
| =        | 赋值                   | `a=12`                   |
| ==       | 相等，一般是作用于比较 | `[ 2 == 2]` 相等返回true |
| !=       | 不等于,用于比较        | `[[ 2 != 2 ]]` 返回false |

##### 关系运算符

关系运算符只支持数字,不支持字符串,除非字符串是数字

| Operator | Descruotion                                         | Example                      |
| -------- | --------------------------------------------------- | ---------------------------- |
| -eq      | 检测两个数是否相等，相等返回true                    | `[ $a -eq $b ]` 返回 false。 |
| -ne      | 检测两个数是否不相等，不相等返回 true。             | `[ $a -ne $b ]` 返回 true    |
| -gt      | 检测左边的数是否大于右边的，如果是，则返回 tru      | `[ $a -gt $b ]` 返回 false   |
| -lt      | 检测左边的数是否小于右边的，如果是，则返回 true     | `[ $a -lt $b ]` 返回 true    |
| -ge      | 检测左边的数是否大于等于右边的，如果是，则返回 true | `[ $a -ge $b ]` 返回 false   |
| -le      | 检测左边的数是否小于等于右边的，如果是，则返回 true | `[ $a -le $b ]` 返回 true    |

##### 布尔运算符

| Operator | Descruotion                                   | Example                                |
| -------- | --------------------------------------------- | -------------------------------------- |
| !        | 非运算符,表达式为true则返回false,否则返回true | [ ! false]返回true                     |
| -o       | 或运算                                        | [ $a -lt 20 -o $b -gt 100 ] 返回 true  |
| -a       | 与运算                                        | [ $a -lt 20 -a $b -gt 100 ] 返回 false |

##### 逻辑运算符

| Operator | Descruotion | Example                                    |
| -------- | ----------- | ------------------------------------------ |
| &&       | 逻辑的AND   | `[[ $a -lt 100 && $b -gt 100 ]]`返回 false |
| \|\|     | 逻辑的OR    | `[[ $a -lt 100 || $b -gt 100]]`返回true    |

##### 字符串运算符

| Operator | Descruotion                             | Example       |
| -------- | --------------------------------------- | ------------- |
| =        | 检测两个字符串是否相等,相等返回true     | `[ $a = $b ]` |
| !=       | 检查两个字符串是否不相等,不相等返回true | `[ $a != $b]` |
| -z       | 检查字符串长度是否为0,是0返回true       | `[ -z $a]`    |
| -n       | 检查字符串长度是否不为0,不为0返回true   | `[ -n $a]`    |
| str      | 检查字符串是否为空,不为空返回true       | `[$a]`        |

字符串的运算符一般是用于,执行某条命令,然后在判断得到的结果。是否存在。或者是函数内返回的值.

运算符就到这里结束

#### Shell变量的作用域

Shell变量的作用域(Scope),就是shell变量的有效范围

shell的变量作用域可以分为三种：

- 全局变量(也就是可以在当前的shell会话中任意使用)
- 局部变量(也就是只能够在一块地方使用。假如函数的内容)
- 环境变量(也就是不管哪里都能够使用的到的)

##### 全局变量

全局变量就是指在当前的shell会话中能够使用的一个变量。因为在shell中。每一个shll都有自己的作用域。互不影响。在shell中定义的变量,默认就是全局变量。

我建立两个终端,在终端1定义一个全局变量a。然后在终端2定义一个变量b。然后交叉输出

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107104912.png)

那么可以看得到在右边的终端定义了一个变量,然后在左边的一个终端输出,并没有输出a的值

这就说明了一个问题,a仅仅就是在右边的终端中有存在，对其他的shell是不存在的。

在命令行定义的变量。在文件中也是可以调用的。

##### 局部变量

shell也是支持函数。但是shell函数中定义的变量。默认就是全局变量。所以需要使用`local`来进行限制为局部变量(也就是只能够在函数中使用)

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107105932.png)

输出的是我上次定义的a的值

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107105950.png)

##### 环境变量

全局变量只能在当前的shell中生效,如果使用`export`命令将它导出,那么在它的所有的子shell中也有效,这就称为环境变量

环境变量被创建的时候,处于的shell是称为父shell,如果父shell中再创建一个shell,则该shell被称为子shell.当子shell产生时,它会继承父shell的环境变量为自己所用。

总的来说就是：环境变量只能向下传递而不能向上传递,就是'传子不传父'

在shell中创建一个子shell的方式就是直接在命令敲`bash`

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107110653.png)

这里看起来是什么都没有发生。但是已经进入了子shell中了。我进入三次,然后使用三个exit来进行退出。

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107110820.png)

使用`export`来定义环境变量然后使得子shell能够使用

![](https://wujinlin.oss-cn-beijing.aliyuncs.com/blog/20181107110901.png)

`export`定义的变量到其他的shell中是没有用的。`export`建立的环境变量是临时的。只要关闭了shell就会自动销毁。







